#include <iostream>
#include "my_vec.h"
/// @brief 
/// @return 
int main()
{
    //Объектно ориентированный подход -- программа стоит из взаимодействующих сущностей - объектов
    //Все объекты принадлежат к какому-то классу. Объекты одного класса устроены одинаково 
    //Объекты чем-то напоминают структуры -- они также хранят набор данных, состоящий из стандартных типов/других объектов
    //Отличие заключается в том, что объекты как правило не предоставлют доступ к хранимым данным напрямую(к в С-style структах),
    //Но предоставляют доступ к ним через интерфес: функции, которые имеют доступ к этим данным
    //Такие функции называются методами. Подобная регламентация доступа является реализацией прицнипа инскапсуляции
    //Подобный подход позволяет нам не заботиться о том, как объекты реализованны внутри
    //Все, что нам нужно знать, какой интерфейс он предоставляет

    // Объектно ориентрированный подход хорошо себе зарекомендовал как в работе с объектами из реальной жизни
    // (Такой пример мы рассмотрим на следующей паре)
    //В нашем курсе (да и в реальной работе физика) нам нечасто приходится создовать классы,
    //соответсвующие предметам реальной жизни
    //однако часто приходится работать с математическими абстракциями - системами уравнений, векторными полями и т.д.
    //Давайте в качестве примера реализуем класс вектор, который реализует структуру данных вектор
    //ДИСКЛЕЙМЕР: пока не реализует в полной мере -- у вектора памяти больше, чем требуется для хранения данных
    //Создаем векторы заполнением
    vector def_arr;
    vector def_arr2(10);

    vector fill_arr(2,4);

    //Создаем вектор с помощью копирования
    vector copied_arr(fill_arr);

    //Также есть перемещающий конструктор!
    vector vec_moved(std::move(fill_arr));

    //Проверяем на равенство
    bool moved_eq_cop = (copied_arr == vec_moved);
    
    bool cop_eq_init = (copied_arr == fill_arr);

    //У нашего вектора естьи другие методы:
    std::cout << "Vector's capacity is " << def_arr.capacity() << " " << " but it's size is " << def_arr.size() << std::endl;

    //Давайте на'pus_back'ем в наш вектор элементов:
    for(size_t i = 0; i < 10; i++)
        def_arr.push_back(i);

    //А теперь выведем все это дело в консоль:
    for(size_t i = 0; i < def_arr.size(); i++)
        def_arr2[i] = def_arr[i];


    //Операция + здесь определена как конкатенация
    vector vec_new = copied_arr + vec_moved;

    //Выводим получившийся вектор
    std::cout << vec_new << std::endl;


    //Заметим, что мы так реализовали интерфейс класса,
    //что работа с ним мало чем отличается от работы с встроенными типами!
    return 0;
}