//Умные указатели и вектор

#include <iostream>
#include <memory> //Умные указатели
#include <cmath>
#include "my_vec.h"
#include "smart_pointer.hpp"

void sp_present_func()
{
    int* p = new int;
    *p = 10;
    sp_int pointer(p); 
    std::cout << "Значение нашего указателя: " << *(pointer) << std::endl; 
}

sp_int pow(sp_int base, sp_int exponent)
{
    return sp_int(new int(pow(*base, *exponent)));
}
int main()
{
    //Давайте познакомимся с концепцией "умного указателя"
    //Проблема обычных указателях -- ручной контроль выделенной памяти
    //К чему это может привести?

    //Мы уже рассмотрели несколько способов, которые позволяют избежать этих проблем:
    //использование ссылок вместо указателей 
    //и контейнеров стандартной библиотеки вместо C-style массивов
    //Если же по какой-то причине приходится использовать указатели,
    //то лучше заменит их на т.н. "умные указатели"

    //Умный указатель -- это класс-обертка над обычным указателем
    //Правильная реализация основных методов (особенно деструктора)
    //позволяет не беспокоится об утечках памяти

    //Давайте сами реализуем простенький "умный указатель", чтобы понять, как он устроен
    sp_present_func();

    //На самом деле мы реализовали т.н. unique_ptr -- у него нет конструктора копирования
    //Это нужно для того при удалении одного объекта sp_int другие не инвалидировались
    //Давайте в этом убедимся (см. smart_pointer.hpp)

    //Как же быть если хочется передать умный указатель в функцию?
    //Можно воспользоваться std::move
    //При этом будет вызван перемещаюший конструктор
    sp_int p1(new int(5));
    sp_int p2(new int(10));

    sp_int res = pow(std::move(p2), std::move(p1));
    //Обратите внимание: p1 и p2 теряют свои значения!

    //Есть также перемещающее присваивание
    p1 = sp_int(new int(50));
    p2 = sp_int(new int(50));

    //Небольшое замечание: 
    //В С++ все сущности можно разделить на две категории:
    //rvalue и lvalue

    //lvalue представляет именованное значение
    //например, переменные, параметры, константы. 
    //lvalue имеет свой адрес в памяти, 
    //к которому можно обратиться и узнать/изменить лежащее в нем значение

    //А rvalue - это то, что можно только присваивать, 
    //например, литералы или результаты выражений.
    
    //например в выражении
    //p1 = sp_int(new int(50));
    //p1 - это lvalue --в него можно что-то записать
    //а sp_int(new int(50)) возвращает rvalue -- результат функции исчезнет на следующем шагу,
    //если его никуда не записать, а выражение
    //sp_int(new int(50)) = new int (20) вызовет ошибку 
    std::cout << "Равны ли указатели: " << (p1 == p2) << std::endl;

    //Умные указатели уже есть std (нет необходимости писать свою реализацию)
    //Для доступа к ним нужно подключить заголовочный файл <memory>
    std::unique_ptr<double> std_up(new double(1.00500));
    //Есть еще shared_ptr -- его можно копировать
    //Проблема досрочного освобождения памяти решается подсчетом числа копий

    //Теперь давайте попробуем реализовать свой класс vector
    //Обсудим некоторые особенности работы с динамической памятью
    vector def_arr;
    vector def_arr2(10);
    vector fill_arr(2,4);

    //Создаем вектор с помощью копирования
    vector copied_arr(fill_arr);

    //Также есть перемещающий конструктор!
    vector vec_moved(std::move(fill_arr));

    vector stranger_things = 10;
    //Проверяем на равенство
    bool moved_eq_cop = (copied_arr == vec_moved);
    
    bool cop_eq_init = (copied_arr == fill_arr);

    //У нашего вектора естьи другие методы:
    std::cout << "Vector's capacity is " << def_arr.capacity() << " " << " but it's size is " << def_arr.size() << std::endl;

    //Давайте на'pus_back'ем в наш вектор элементов:
    for(size_t i = 0; i < 10; i++)
        def_arr.push_back(i);

    //А теперь выведем все это дело в консоль:
    for(size_t i = 0; i < def_arr.size(); i++)
        def_arr2[i] = def_arr[i];


    //Операция + здесь определена как конкатенация
    vector vec_new = copied_arr + vec_moved;

    //Выводим получившийся вектор
    std::cout << vec_new << std::endl;


    
    return 0;
}