#include <iostream>
//Сегодня мы познокомимся с:
//1. Контейнерами (самые базовые)
//2. Ссылками

//Последовательные контейнеры
#include <vector> // Подключаем нужный заголовочный файл - по названию используемого контейнера 
// Также есть array, list, forward_list, deque, stack и т.п.

// Ассоциативные
#include <set> // множество - набор уникальных однородных элементов
#include <map> // а также: multiset, multimap и т.п.

using namespace std;

int main()
{
    //В языке С для хранения множества элементов одного типа использовались МАССИВЫ
    //Статические:
    int mas [] = {1, 2, 3, 4, 5, 6};
    //И динамические:
    double* pMas = new double [6]; //new вместо malloc
    //А для работы с ними использовали for:
    for(int i = 0; i < 6; i++)
        *(pMas + i) = mas[i]*mas[i];
    delete[] pMas; //Освобождаем память

    //С какими проблемами вы сталкивались при работе с массивами (особенно динамическими)?
    
    //Стандартная библиотека C++ предоставляет большой набор контейнеров, 
    //которые позволяют удобно хранить и работать с наборами однотипных данных

    //Для работы с контейнерами надо включить одноименный заголовочный файл (см. #include)

    //Создадим vector - вероятно самый популярный контейнер
    //vector - динамический массив с автоматическим перевыделением памяти 

    vector<int> vect_i; // Пустой вектор с элементами типа int
    vector<vector<double>> vect_vect(10); // Вектор векторов с элементами типа double размером 10 

    vector<string> vect_str(10, "element"); // Вектор c элементами типа string, размером 10, каждая строка = "element"
    vector<float> vector_f = {1., 1.1, 1.2, 1.3, 1.4, 1.5}; // С помощью списка инициализации
    
    //Обращение к элементу также как в string: [] или .at():

    vect_str.at(9) = "last_one_element";

    //Полезные методы контейнера vector
    //Можно добавлять элементы  в конец с помощью метода pushed_back:
    vect_str.push_back("pushed_back_one");
    //Память выделяется также как в string -- с запасом

    cout << "Размер: " << vect_str.size() << ", емкость: " << vect_str.capacity() << endl;

    //Можно изменять размер:
    vect_vect.resize(20);
    
    //В С++ цикл for может перебрать все элементы контейнера без использования индексов
    for(string str: vect_str)
    {
        cout << str << ' ';
        str = "already printed"; // А внесутся ли изменения?
    }


    //Не особо
    //Для этого можно воспользоваться ссылками
    //Можно сказать, что ссылка -- это создание перменной с памятью, которая уже принадлежит другой переменной
    //Таки образом, меняя данные в ссылке изменяется и исходная перменная (обратное утверждение тоже верно)
    //Ссылки были введены, как замена указателей (для некотрых целей), которая не страдает их "проблемами":
    //обращение к неинициализированной памяти, ошибки при работе с арфиметикой указателей и т.д. 
    //Давайте создадим ссылку:
    int a = 10;
    int& b = a; //тип_& имя_переменной
    b *= 2;
    cout << "Адрес а: " << &a << ", адрес b" << &b << endl;

    
    for(string& str : vect_str) // Ссылки!
    {
        str = "already printed";
    }
    vect_str.clear();


    //Теперь к ассоциативным контейнерам
    //Множество -- набор уникальных однотипных элементов
    set<int> our_set{5, 5, 4, 3, 2, 1};

    our_set.insert(6);
    our_set.insert(1);

    // our_set[1] -- так нельзя!

    // приходится перебирать циклом: 
    for(int el: our_set) // & - нельзя
    {
        cout << el << " ";
        //el+=1; 
    }
    
    map<string, int> our_map{{"one", 1}, {"two", 2}, {"three", 3}};
    //Хранит набор пар: ключ-значение, ключи должны быть уникальные
    //каждая пара хранится в специальном типе pair<type, type> --
    // -- это структура c двумя полями first -- для ключа, second -- для значения

    our_map["one"] = 2; // изменит значение на 2
    our_map["four"] = 4; // если ключа нет -- создает его
    our_map["four"] += 4; // добавит к four 4
    our_map["five"] += 5; // создаст "five" и инициализирует 5, а если бы ключ был, то прибавил бы 5
    //our_map.at("+100500"); -- ошибка!

    //Про сравнение map

    return 0;
}

