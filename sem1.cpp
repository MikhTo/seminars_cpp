//План первого семинара:
//1. Строки в С++
//2. Потоки: считывание и вывод в консоль, запись и чтение из файла
//3. Перегрузка функций (и методов)

#include <iostream> //Для работы со стандартными потоками ввода/вывода
#include <fstream> // Для работы с файлами
#include <string> // Для работы со строками


//Перегруженные функции (описание в конце файла):

int mult(int x, int y)
{
    return x*y;
}

std::string mult(std::string str, time_t times)
{
    std::string res;
    for (int i = 0; i < times; i++)
        res+=str;
    return res;
}
int main()
{
    //Краткое напоминание: на прошлом уроке мы познакомились с cout/cin
    
    //cout для вывода в консоль: 
    std::cout << "Hello, my friend\n" << "It's " << 2 <<"'th C++/Python lesson" << std::endl;

    //cin для записи:
    int some_numb;
    std::cout << "Введите любое число:" << std::endl;
    std::cin >> some_numb;
    std::cout << "Ваше число:" <<some_numb<< std::endl;

    //Строки в языке С представляли собой нуль-терминированный массив типа char
    // Их тоже можно использовать в С++ они называются С стайл строками
    char str_c [] = "It's C style string\n";
    const char* str = "Iy's literal string";
    std::cout << str_c << str <<std::endl;

    //Однако в стандартной библиотеке С++ есть более удобное решение для работы со строками: std::string

    std::string first, second, third(6, 't'), fourth("fourth"); // создание строки

    std::cin >> first >> second; // Можно считывать строки из стандартного потока
    
    //Можно отправлять в стандартный поток
    std::cout << "Содержание первых двух строк, полученное из консоли: " << first << '\t' << second << std::endl; 

    std::cout << "Содержимое третьей и четвертой строк, инициализированных при создании: " << third << '\t' << fourth << std::endl;


    //обращаться к элементам строки можно через [] или через .at()
    std::cout << "Обращаемся к элементам по индексу: " << third[3] << " " << fourth.at(4) << std::endl;
    
    fourth += fourth;  // +. +=, .append() - операция конкатенации -- сложения строк
    std::cout << "Конкатенация: " << fourth << " " << first + second << " " << fourth.append("the end!") << std::endl;

    //Строки можно сравнивать лексикографически
    std::cout << "Результат third > fourth: " << (third > fourth) << std::endl; //доступны <, >, <=, >=, ==, !=

    std::string a("abcd");
    std::cout << "Новая строка, с которой будем работать: " << a << std::endl;
    std::cout << "Узнать размер можно с помощью .size() или .length(): " << a.size() << std::endl;

    std::cout <<"Однако места в памяти требуется больше, чем на строку: "<< a.capacity() << std::endl; 
    //  Почему так? Чтобы можно было добавлять символ в конец без перезаписи

    a.push_back('e');
    std::cout << "Добавили \'e\' с помощью .push_back(): " << a << std::endl;
    //А убрать можно с помощью pop_back();
    a.pop_back();
    std::cout<< "А теперь убрали при помощи pop_back(): " << a << std::endl;

    //Полезный метод find() -- ищет первое вхождение
    std::string phrase("NSU is the novosibirsk State University");
    std::cout << "Новая строка для работы: " << phrase << std::endl;
    std::cout << "Позиция \"si\", найденная с помощью метода find: " << phrase.find("si") << std::endl;
    std::cout << "Позиция второго вхождения \"si\" при передаче методу find в качестве второго аргумента индекс"
    " первого вхождения: " << phrase.find("si", phrase.find("si") + 1) << std::endl; // Второй параметр -- точка старта поиска

    // А вот так можно менять регистр (для понижения функция tolower)
    phrase.at(phrase.find("novo")) = std::toupper(phrase[phrase.find("novo")]); 

    std::cout << "Повышаем регистр у буквы n в слове \'novosibirsk\': " << phrase << std::endl;


    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //Лирическое отступление: что такое метод?
    //Наверное у тех из вас, кто не знаком с С++ возникает вопрос, что вообще происходит, когда мы пишем:
    // some_string.some_methode()
    // Подробный ответ будет дан ближе к середине курса, а сейчас для удовлетворения любопытства огранимся сл. рассуждением
    //Давайте считать, что объекты типа std::string -- это структуры, полем которого является обычный char массив
    // .some_methode() -- это вызов специальной функции, которая может поработать с этим "внутренним" массивом,
    //например изменить значение кого-то элемента, вытащить значение i-го элемента или найти первое вхождение какого-то символа
    // такие функции называются методами  
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////


    
    //Теперь немного поговорим про потоки:
    // С стандартными потоками ввода/вывода мы уже познакомились: cout/cin
    // Сегодня также обсудим, как направить потоки ввода/вывода в файл

    //Для того, чтобы что-то считать из файла, надо привязать его у объекту типа ifstream
    std::ifstream ifile("some_file.txt", std::ios::in);

    //Считать же информацию можно несколькими способами:
    if(ifile.is_open())
    {
        //1. До первого разделителя:
        std::string str_ff1;
        ifile >> str_ff1;

        //2. Посимвольно:
        char c;
        ifile.get(c);

        //3. И до перевода строки
        std::string line;
        getline(ifile, line);
    }
    

    //Запись в файл устроена схожим образом:
    std::cout << "Введите что-нибудь для записи" << std::endl;
    //Вопрос: зачем создавать line, она же уже создавалась?
    std::string line;
    std::cin >> line;
    std::ofstream ofile("new_file.txt", std::ios::out);
    if (ofile.is_open())
    {
        ofile << line;
    }

    //А так происходит дозапись:
    std::fstream file("some_file.txt", std::ios::app);
    file << "\nAnd we dream of grass, grass at home\nOf green, green grass";

    // Вопрос на засыпку: что может смутить человека изачашего только С в следующих двух строках:
    //int first = str.find('a');
    //int second = str.find('a', first+1);





    //Ответ: тут мы видим функцию (на самом деле метод) find, которая можете быть вызвана с РАЗНЫМ кол-вом параметров
    //Дело в том, что в С++ можно создавать функции с ОДИНАКОВЫМ именем, но разным набором параметров
    // т.е. сигнатуры функций должны хоть чем-то отличаться
    //Создание нескольких функции с одинаковым именем, но с разными параметрами называется ПЕРЕГРУЗКОЙ
    //Перегрузка позволяет не придумывать разные названия для функций со схожей функциональностью (пример: тот же метод .find()) 
    //В начале файла мы создали две функции с одинаковым названием mult, а здесь их вызываем

    std::cout << "mult(int, int): " << mult(2,2) << " mult(str, int): " <<mult("hello", 3)<< std::endl;
    return 0;
}