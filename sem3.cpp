#include <iostream>
#include <vector>
#include <set>
#include <map>


#include <array> 
#include <stack> 
#include <deque>
#include <list>

int main()
{
    std::array<int, 3> arr {1, 2, 3};
    //В целом все тоже самое, что у вектора, но нельзя изменять размер
    //соответствено, нет методов .push_back(), .resize()

    //обращение -- либо через .at() и []
    arr.at(2) = arr[0];

    //В целом все просто
    //Мы начали разговор про array только потому, что он понадобится в одной из задач

    //deque -- контейнер, который очень похож на вектор (тоже константная доступа и поиска), 
    //но позволяет эффективно добавлять элементы не только в начало, но и в конец
    std::deque<std::string> dq = {"first", "second", "third"};
    dq.push_back("forth");
    dq.push_front("zeroth");
    //Остальные методы как у вектора
    //Казалось бы, зачем тогда нужен вектор, у которого нет эффективного добавления в начало?
    //На самом деле у дэка доступ к i-му элементу где-то на треть медленей, чем у вектора (хотя тоже константный)

    //list - реализация двусвязного списка
    //В двухсвязном списке каждый элемент имеет знает (имеет указатели) на предыдущий и следующий за ним элемент
    std::list<std::string> lst{"one", "two", "three"};
    lst.push_back("last_element");
    lst.push_front("first_element");
    for(const std::string& str: lst)
        std::cout << str << std::endl;

    lst.pop_back();
    lst.pop_front();


    //stack может пригодиться в задачах "Баланс скобок" и "Вычисление арифметического выражения"
    //Стек работает по принципу FILO -  First in, Last in.
    //т.е. стека есть две операции - добавить элемент сверху и снять его сверху,
    //иными словами, последний добавленный элемент в стек первым из него изымается
    //При этом мы имеем доступ только к последнему элементу стэка (его вершине)

    std::stack<double> our_stack; // Создали stack с элементами типа double

    our_stack.push(1.2); // Положили на вершину стэка 1.2
    our_stack.push(1.5); // Положили на вершину стэка 1.5

    //Если хотим узнать, что лежит сверху -- используем .top()
    std::cout << "Что же лежит на верщине стэка? А вот что: " << our_stack.top() << std::endl;
    //Изменили?
    our_stack.top() = 10.;

    //У стэка убирается только верхний элемент
    our_stack.pop();

    std::cout << "Сделали .pop() --- вершиной стал предыдущий элемент: " << our_stack.top() << std::endl;

    std::cout << "Ну еще можно размер узнать: " << our_stack.size() << std::endl; //Можно еще узнать, пуст ли стэк --- .empty()
    //На самом деле stack не совсем полноценный контейнер...
    //stack относится к т.н. адаптерам
    //Адаптеры -- это реализация той или иной структуры данных
    //с помощью урезания функционала лежащего в основе контейнера
    //например у стэка в основе лежит deque
    //но можно положит в основу другой контейнер, например list:
    std::stack<std::string, std::list<std::string>> listostack;

    // Итераторы
    //Итераторы -- это объекты, которые используются для доступа к элементам контейнера
    //Давайте создадим итератор для вектора:
    std::vector<int> vec{1, 2, 3, 4, 5, 6, 7, 8, 9};
    //Создать итератор -- тип_контейнера::iterator имя_переменной
    std::vector<int>::iterator it = vec.begin(); //метод begin возвращает итератор первого элемента контейнера

    //Можно перебрать вектор (и любой другой контейнер) с помощью итераторов:
    //vector.end возращает итератор на конец массива
    //формально на элемент следующий за последним
    while(it != vec.end())
    {
        //Для получения значения элемента, который соответсвует итератору,
        //используется оператор *
        std::cout << *it << std::endl;
        //Для итератора определена операция ++
        //после нее it указывает на следующий элемент
        it++;
    }
    //На что похож итератор?

    //также итератор можно использовать для вставки элемента(ов)
    std::vector<int> tail {10, 11, 12};
    vec.insert(it, tail.begin(), tail.end());

    //Обратные итераторы:
    //Можно использовать, чтобы перебрать контейнер в обратном порядке
    auto rit = vec.rbegin(); //ключевое слово auto автоматически определяет тип переменной
    while(rit != vec.rend())
    {
        std::cout << *rit << std::endl;
        rit = std::next(rit); //next - альтернатива ++ 
    }
    //также с помощью них можно лего обратить массив
    std::vector<int> r_vec(vec.rbegin(), vec.rend());
    
    //Таким же образом можно создать любой контейнер по двум итераторам (необязательно обратным)

    //Итераторы для разных контейнеров обладают разным набором свойств
    //Так итераторы для vector, array и deque самые крутые (Random access iterators)
    //Для них доступны операции
    //Переход на элемент вперед: ++ или std::next, и назад: -- или std::prev
    //Переход на n элементов в любую сторону: либо iterator + n, либо std::advance(iterator, n)
    
    //ВАЖНО: можно уйти за пределы контейнера, проверка размер лежит на вас!
    
    //Сравнение (по позиции): >, <, == и т.д.


    //Контейнеры set, map и list обладают более слабой категорией итераторов: Bidirectional iterators
    //Для них определены операции смещения на ОДИН элемент вперед или назад: ++ и --
    auto biter_l = lst.begin();
    std::cout << *biter_l << ", смещаемся на 1: " <<*(++biter_l) << std::endl;
    //перемещаться сразу на несколько позиций можно с помощью std::advanced, но помните,
    // что это дорогая операция (выполняется за O(N))
    //у списка есть удобный метод splice, который позволяет перемещать "сшить" несколько списков
    std::list l1 = {1, 2, 3};
    std::list l2 = {4, 5, 6};
    std::list l3 = {7, 8, 9};
    //кстати не заметили ничего интересного при инициализации?

    l1.splice(l1.end(), l2);
    l1.splice(l1.begin(), l3);

    //итераторы используются для эффективного поиска в ассоциативных контейнерах
    //сделаем map для того, чтобы это продемонстрировать
    const std::map<std::string, long long int> phone_book {
        {"Saul", 88002253535},
        {"Mr.Shelby", 89997775656},
        {"Mr. Smith", 89097651234 },
        {"Mrs. Smith", 89094321567}
    };

    //.find() производит эффективный поиск
    auto smth = phone_book.find("Mr. Smith");

    //Инвалидация итераторов
    //После некоторых действий итератор может начать указывать на несуществующий элемент
    std::vector<int> nice_vec {1,2,3};
    auto strange_it = nice_vec.begin();
    nice_vec.shrink_to_fit();
    nice_vec.push_back(4);
    //Что же произойдет?
    
    return 0;
}